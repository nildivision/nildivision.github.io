<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Static File Viewer</title>
  <style>
    body {
      background: black;
      color: white;
      font-family: monospace;
      padding: 1rem;
      display: flex;
      gap: 1rem;
      height: 100vh;
      margin: 0;
      box-sizing: border-box;
    }
    .tree {
      white-space: pre;
      width: 350px;
      border: 1px solid #444;
      padding: 1rem;
      overflow-y: auto;
      background: #111;
      box-sizing: border-box;
    }
    .file:hover, .folder:hover {
      background-color: #222;
      cursor: pointer;
    }
    .folder {
      user-select: none;
    }
    #viewer {
      width: 600px;
      background: #111;
      padding: 1rem;
      border: 1px solid #444;
      overflow: auto;
      max-height: 100vh;
      box-sizing: border-box;
    }
    img, video, audio {
      max-width: 100%;
      max-height: 80vh;
      display: block;
      margin: 0 auto;
    }
    video, audio {
      background: #000;
    }
  </style>
</head>
<body>
  <div class="tree" id="file-tree">Loading...</div>
  <div id="viewer"></div>

  <script>
    async function fetchTree() {
      const res = await fetch('tree.json');
      return res.json();
    }

    function isImageFile(filename) {
      return /\.(png|jpe?g|gif|webp|bmp|svg)$/i.test(filename);
    }

    function isAudioFile(filename) {
      return /\.(mp3|ogg|wav|m4a|aac)$/i.test(filename);
    }

    function isVideoFile(filename) {
      return /\.(mp4|webm|ogv|mkv)$/i.test(filename);
    }

    function buildTreeLines(nodeList, prefixes = [], basePath = '') {
      let lines = [];

      nodeList.forEach((node, idx) => {
        const isLast = idx === nodeList.length - 1;
        let prefixStr = '';
        for (let i = 0; i < prefixes.length; i++) {
          // Skip the first prefix always, as root has no branch line
          if (i === 0) continue;
          prefixStr += prefixes[i] ? '│  ' : '   ';
        }
        // No branch line for root (when prefixes.length === 0)
        const branch = prefixes.length === 0 ? '' : (isLast ? '└─ ' : '├─ ');
        const fullPath = basePath + node.name;

        const line = document.createElement('div');

        if (node.children) {
          const toggle = document.createElement('span');
          toggle.textContent = '>'; // collapsed by default
          toggle.style.marginRight = '4px';

          const label = document.createElement('span');
          label.textContent = node.name + '/';
          label.className = 'folder';

          const childContainer = document.createElement('div');
          childContainer.style.display = 'none';
          childContainer.style.marginLeft = '0';

          const childLines = buildTreeLines(node.children, prefixes.concat(!isLast), fullPath + '/');
          childLines.forEach(child => childContainer.appendChild(child));

          line.appendChild(document.createTextNode(prefixStr + branch));
          line.appendChild(toggle);
          line.appendChild(label);

          // Make folder line full width and clickable
          line.style.display = 'flex';
          line.style.alignItems = 'center';
          line.style.width = '100%';
          line.style.cursor = 'pointer';
          label.style.flexGrow = '1';

          // Make toggle cursor default (not pointer)
          toggle.style.cursor = 'default';

          line.onclick = () => {
            const isVisible = childContainer.style.display === 'block';
            childContainer.style.display = isVisible ? 'none' : 'block';
            toggle.textContent = isVisible ? '>' : 'v';
          };

          lines.push(line);
          lines.push(childContainer);
        } else {
          line.className = 'file';
          line.textContent = prefixStr + branch + node.name;

          line.onclick = () => {
            const viewer = document.getElementById('viewer');
            viewer.innerHTML = '';

            const src = 'files/' + fullPath;

            if (isImageFile(fullPath)) {
              const img = document.createElement('img');
              img.src = src;
              viewer.appendChild(img);
            } else if (isAudioFile(fullPath)) {
              const audio = document.createElement('audio');
              audio.controls = true;
              audio.src = src;
              viewer.appendChild(audio);
            } else if (isVideoFile(fullPath)) {
              const video = document.createElement('video');
              video.controls = true;
              video.src = src;
              viewer.appendChild(video);
            } else {
              fetch(src)
                .then(res => res.text())
                .then(text => {
                  const pre = document.createElement('pre');
                  pre.textContent = text;
                  viewer.appendChild(pre);
                });
            }
          };

          lines.push(line);
        }
      });

      return lines;
    }

    async function renderTree() {
      const data = await fetchTree();

      const treeContainer = document.getElementById('file-tree');
      treeContainer.innerHTML = '';

      const lines = buildTreeLines(data, [], '');
      lines.forEach(line => treeContainer.appendChild(line));
    }

    renderTree();
  </script>
</body>
</html>
